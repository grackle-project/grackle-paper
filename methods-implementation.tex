\section{Implementation} \label{methods:code}

In this section, we discuss details of the code, itself, including the
available application program interfaces (APIs), code layout, and how
the existing models and networks may be extended.  For more detailed
information, users should consult online documentation available at
\texttt{https://grackle.readthedocs.org}.

\subsection{Simulation Code API}

The Grackle library provides five main functions to the user for use
in simulation codes: solving the chemistry and cooling (i.e.,
updating the chemical species and internal energy) and calculating the
cooling time, temperature, pressure, and ratio of specific heats.
Before these functions can be called, the code must be initialized
with various user-specified settings.  This initialization process is
also responsible for loading data from external files and calculating
chemistry and cooling rate tables used by the solvers.  The
initialization process can be carried out in two different ways.
\begin{enumerate}
\item[(i)] The Grackle stores all configuration parameters and data
  tables within a single \texttt{C} struct that exists within the
  primary grackle header file, \texttt{grackle.h}.  In the first
  method, the user initializes this structure by calling the function,
  \texttt{set\_default\_chemistry\_parameters}.  All parameters can
  then be set by accessing them directly from the struct, called
  \texttt{grackle\_data}.  Once all parameters are properly set, the
  user must call \texttt{initialize\_chemistry\_data} to finalize the
  initialization process.  This method is advantageous as it allows
  the user to access all configurable parameters directly, including
  ones that may be added in the future, without additional function
  calls.  An example of this procedure is shown below:

\vspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\begin{verbatim}

int rval;
rval = set_default_chemistry_parameters();

grackle_data.use_grackle = 1;
grackle_data.with_radiative_cooling = 1;
grackle_data.primordial_chemistry = 3;
grackle_data.metal_cooling = 1;
grackle_data.UVbackground = 1;
grackle_data.grackle_data_file = 
  "CloudyData_UVB=HM2012.h5";

rval = 
  initialize_chemistry_data(&my_units, a_value);

\end{verbatim}
\end{minipage}

In the above example, the variable \texttt{my\_units} is a C
\texttt{struct} that holds unit conversions from internal code units
to the CGS unit system for quantities such as density, length, and
time.  The variable, \texttt{a\_value}, holds the current value of the
expansion factor ($a \equiv 1/(1+z)$, where z is the redshift).  These
are required in order to set up the internal unit system for the
chemistry and cooling rate tables.

\item[(ii)] The above method can be combersome to work with in a
  simulation code written in \texttt{Fortran} because of the necessity
  of dealing with \texttt{C} structs.  For this reason, the Grackle
  offers a second initialization procedure involving only a call to
  the function, \texttt{initialize\_grackle}.  All arguments to this
  function are simple scalar integers and floats.  Internally, this
  function follows the procedure outlined above.  The disadvantage of
  this method is that it only provides access to the most frequently
  used parameters as making all parameters available would constitute
  a overly long list of arguments.

\end{enumerate}

Once the Grackle has been initialized, the functionality described
above can be called by the simulation code.  The available functions
are: 1) \texttt{solve\_chemistry} to integrate chemistry and cooling
equations over a specified time step, 2)
\texttt{calculate\_cooling\_time} to calculate the cooling time
($e/(de/dt)$) for each computational element, 3)
\texttt{calculate\_temperature} to calculate the temperature from the
internal energy and chemical species densities, 4)
\texttt{calculate\_pressure} to calculate the gas pressure, and 5)
\texttt{calculate\_gamma} to calculate the ratio of specific heats.
In the Grackle, the ratio of specific heats is only altered from that
of an ideal gas by the presence of H$_{2}$.  For each of these
functions, the required arguments are the various unit conversion
factors, arrays of internal energy, total density, densities of each chemical
species (if the non-equilibrium solver is used), and arrays describing
the size and shape of the primary data arrays.  The Grackle can be
compiled to either accept the data arrays as single or double
precision floating point type.  Both the non-equilibrium and fully
tabulated functionality are available through the above functions.
When the fully tabulated mode is used, the chemical species arrays may
simply be \texttt{NULL} pointers.  For simplicity, the Grackle also
provides tabulated-only functions appended with \texttt{\_table} which
only require the total density field to be given.

\subsection{Pygrackle - Grackle's Python API}

\subsubsection{Fluid Container} \label{sec:pyfluid}

\subsubsection{Evolution Models} \label{sec:pyevolve}

- constant density model

- free-fall model

\subsection{Code Structure} \label{Code_Structure}

\subsection{\jr{Adding New Models/Rates}}

Adding new rates to Grackle involves modifying the values stored in the rate coefficients and 
additionally defining a new network for both the chemistry and if desired also the cooling. As it stands the
code is not sufficiently modular to allow this task to be completed with significant ease and some
hands on manipulation of the code structure is required (see \S \ref{Future_Directions} for 
future improvements in this regard). \\
\indent When considering a manipulation of the Grackle code base an important consideration is that the structure
of the current code base is set up to realize either an equilibrium chemistry model using cooling tables
derived from Cloudy or a non-equilibrium cooling model based on a six, nine or twelve species cooling model. 
If your wish is to implement a different equilibrium cooling model then the process is relatively straight
forward. Grackle reads the cloudy cooling and interpolates the data along one, two or three dimensions as
appropriate. By substituting in a different cooling table the behavior of the cooling for a given species
can be manipulated. The format of the cooling table should however match the format of the Cloudy cooling
tables. \\
\indent If on the other-hand your intention is to manipulate the non-equilibrium cooling behavior then more
code manipulation will be required. Grackle assumes that non-equilibrium cooling models are hierarchical
with the nine species model containing the six species model plus three additional components for example. 
If the intention is to expand the network to include a fourth model containing the twelve species model as 
a subset then the procedure is straight forward. However, if a different chemical network is envisaged 
containing some species already in the twelve species model and some not then this will require more care. 
The flow of the chemistry network is controlled by the primordial\_chemistry flag, 
primordial\_chemistry = 1 for the six species model, primordial\_chemistry = 2 for the nine species model and
primordial\_chemistry = 3 for the twelve species model. In general through out the code an if clause of 
if(primordial\_chemistry > 0) is followed by else if (primordial\_chemistry > 1) which means that instructions
are carried out consecutively assuming one model is a subset of a higher order model.
For example say we wish to implements a 10 species model using the current 9 species set and one other element. 
Two options exist in this case. We could implement a 13 species model and set primordial\_species = 4 and 
update the code accordingly to deal with an additional species setting the Deuterium species to zero in input.
This would be straight forward but somewhat wasteful. The alternative option would be to adjust the 
primordial\_species = 2 criteria to include an extra species. This species would also need to be added into
Grackle API. In both of these cases the hierarchical nature of the code would be preserved. \\
%\indent In the following 
%example we will discuss the more straight forward case of a 15 species model. The new model will 
%contain the original twelve species model plus new three chemical elements to evolve - 
%primordial\_chemistry = 4 as a result becomes our fictional 15 species model.

\subsubsection{Updating the Rate Coefficients}
As described in \S \ref{Code_Structure} the rates are allocated and declared in initialize\_chemistry.c. If the
intention is to use your own rate coefficients (say based on more recent experimental data) then 
it would still be prudent to make use of the already existing rate coefficient arrays (k array) as declared
in initialize\_chemistry.c. The rates are populated in calc\_rates\_g.F. Within this function the rates 
are fully described. For example k1 is the rate coefficient for the collisional ionization of neutral 
Hydrogen (k1: HI + e -> HII + 2e). If a significant number of new rate coefficients are desired then 
the most expedient approach would be to insert a \#define preprocessor directive into calc\_rates\_g.F
into which your appropriate function call can be inserted. In this case upon compilation your new function 
will populate all of the rate coefficients required for your new network. Your function can use the 
routine coll\_rates\_g as a template for how to implement a new set of rate coefficients. Any rates that are not
set in the new routine will be set to a very small number and will therefore not effect the calculation.\\
\indent For any additional rate coefficients that are required the k array needs to be declared and allocated
in initialize\_chemistry.c. These rates can then be used to model the chemical behavior of the new species
as a function of temperature and density as required. Furthermore, in the function lookup\_cool\_rates1d\_g 
in solve\_rate\_cool\_g.F the interpolation of the new rates will need to be added. 


\subsection{Updating the chemistry network}
If in addition (or independently) you wish to update the chemical network to either include or exclude
reactions then a new rate network will be required. As a template the function step\_rate in 
solve\_rate\_cool\_g.F can be used. This function currently evolves both the six, nine and twelve species 
models. To modify this network you can either create a new chemistry solver following the 
existing solver's methods as a guide or create a new routine which solves the chemical network. If the 
new network is simply an addition to the existing network (e.g. a 15 species model) then the easiest 
option is to simply augment this network with the three extra species using the appropriate 
interactions. The species will then be evolved until they converge.

\subsection{Updating the cooling network}
Apart from the chemical network the cooling network may also be modified. As discussed previously if the intention
is to implement a new cooling table then the changes are straight forward. Once the tables are formatted correctly
Grackle will the new values to calculate a new temperature. If instead we want to modify the cooling rate due 
to emission line cooling from given species this is handled in the cool1d\_multi\_g.F. As discussed in \S
\ref{Cooling} line emission cooling is determined using collisional excitation, collisional ionization and 
recombination rates. If the intention is to update/modify existing rates then the cooling rates are also set
in calc\_rates\_g.F and can be modified here. If new cooling rates are required from another species 
whose cooling properties are important for the network then the rates can be added here also. Any new arrays
required in this case will also need to be declared and initialized in initialize\_chemistry.c similar to the
rate coefficients. The rates can then be interpolated to the required temperature values in calc\_rates\_g.F 
following the examples there. Once the new cooling rate has been determined it's values needs to be added
to the edot array so that the cooling effects of this new species is properly account for.


